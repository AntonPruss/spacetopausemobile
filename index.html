<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pixelated Pattern Generator</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="pixelCanvas"></canvas>
  <script>
    const canvas = document.getElementById('pixelCanvas');
    const ctx = canvas.getContext('2d');

    // fixed grid
    const patternCols = 300;
    const patternRows = 200;
    let cellWidth, cellHeight;
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cellWidth = canvas.width / patternCols;
      cellHeight = canvas.height / patternRows;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // hard‚Äêcoded retro palette
    const retroColors = ['#eeeeee', '#979797', '#666666', '#000000'];

    function getRandomColor() {
      return retroColors[Math.floor(Math.random() * retroColors.length)];
    }

    function generatePattern(cols, rows) {
      const p = [];
      for (let y = 0; y < rows; y++) {
        const row = [];
        for (let x = 0; x < cols; x++) {
          row.push(getRandomColor());
        }
        p.push(row);
      }
      return p;
    }

    let currentPattern = generatePattern(patternCols, patternRows);
    let pauseTextPattern = generatePattern(100, 35);

    let offsetX = 0;
    let isPaused = false;

    function drawPattern() {
      ctx.imageSmoothingEnabled = false;
      for (let y = 0; y < patternRows; y++) {
        for (let x = 0; x < patternCols; x++) {
          ctx.fillStyle = currentPattern[y][(x + offsetX) % patternCols];
          const drawX = Math.floor(x * cellWidth);
          const drawY = Math.floor(y * cellHeight);
          ctx.fillRect(drawX, drawY, Math.ceil(cellWidth), Math.ceil(cellHeight));
        }
      }
    }

    // PAUSE text template (using '*' to draw pixels)
    const pauseText = [
      "        ************************************             ***********************************                                   ****************                                  ************************************             *******************************************",
      // ... (keep all your existing PAUSE lines here) ...
      "         "
    ];
    const textCols = pauseText[0].length;
    const textRows = pauseText.length;

    function drawPauseText() {
      ctx.imageSmoothingEnabled = false;
      const startX = Math.floor(patternCols / 2) - Math.floor(textCols / 2);
      const startY = Math.floor(patternRows / 2) - Math.floor(textRows / 2);

      for (let row = 0; row < textRows; row++) {
        for (let col = 0; col < pauseText[row].length; col++) {
          if (pauseText[row][col] === '*') {
            const color = pauseTextPattern[row % pauseTextPattern.length][col % pauseTextPattern[0].length];
            ctx.fillStyle = color;
            const drawX = Math.floor((startX + col) * cellWidth);
            const drawY = Math.floor((startY + row) * cellHeight);
            ctx.fillRect(drawX, drawY, Math.ceil(cellWidth), Math.ceil(cellHeight));
          }
        }
      }
    }

    function animate() {
      if (!isPaused) {
        offsetX = (offsetX + 8) % patternCols;
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawPattern();
      drawPauseText();
      requestAnimationFrame(animate);
    }

    // Spacebar to pause/resume
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') isPaused = true;
    });
    window.addEventListener('keyup', e => {
      if (e.code === 'Space') isPaused = false;
    });

    // Touch to pause/resume
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      isPaused = true;
    }, { passive: false });
    canvas.addEventListener('touchend', () => {
      isPaused = false;
    });

    animate();
  </script>
</body>
</html>
